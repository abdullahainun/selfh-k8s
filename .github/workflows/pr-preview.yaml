# .github/workflows/pr-preview.yml
name: PR Preview Environment

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    paths:
      - "apps/**"
      - "clusters/homelab/03-community/**"

# Add permissions for commenting on PRs
permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: read

# Remove KUBECONFIG_DATA - tidak perlu lagi karena kubectl sudah available di runner
env:
  DOMAIN_GENERATOR_URL: "https://dg.homelab.local"
  INTERNAL_SERVICE_IP: "10.10.10.101" # IP untuk load balancer/ingress
  DOMAIN_PORT: "80"

jobs:
  detect-changes:
    runs-on: self-hosted # Changed from ubuntu-latest
    outputs:
      services: ${{ steps.changes.outputs.services }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed services
        id: changes
        run: |
          # Detect which services were changed
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          echo "Changed files: $CHANGED_FILES"

          # Extract service names from changed paths
          SERVICES=$(echo "$CHANGED_FILES" | grep -E '^app/[^/]+/' | cut -d'/' -f2 | sort | uniq | tr '\n' ' ')
          COMMUNITY_REFS=$(echo "$CHANGED_FILES" | grep -E '^clusters/homelab/03-community/' | sed 's|.*/||' | sed 's|\.yaml$||' | tr '\n' ' ')

          # Combine and deduplicate
          ALL_SERVICES=$(echo "$SERVICES $COMMUNITY_REFS" | tr ' ' '\n' | sort | uniq | tr '\n' ' ')

          # Remove leading/trailing spaces
          ALL_SERVICES_TRIMMED=$(echo "$ALL_SERVICES" | sed 's/^ *//;s/ *$//')

          echo "services=$ALL_SERVICES_TRIMMED" >> $GITHUB_OUTPUT
          if [ -n "$ALL_SERVICES_TRIMMED" ]; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

          echo "Detected services: $ALL_SERVICES_TRIMMED"

  preview-deploy:
    runs-on: self-hosted # Changed from ubuntu-latest
    needs: detect-changes
    if: github.event.action != 'closed' && needs.detect-changes.outputs.has-changes == 'true'

    steps:
      - uses: actions/checkout@v4

      # Deploy each service sequentially instead of using matrix
      - name: Deploy services to preview
        run: |
          SERVICES="${{ needs.detect-changes.outputs.services }}"
          PR_NUMBER="${{ github.event.number }}"
          BRANCH_NAME="${{ github.head_ref }}"

          echo "Services to deploy: $SERVICES"
          echo "PR Number: $PR_NUMBER"
          echo "Branch: $BRANCH_NAME"

          # Initialize temp file for domain info
          > /tmp/preview-domains.txt

          # Process each service
          for SERVICE in $SERVICES; do
            echo "========================================"
            echo "Processing service: $SERVICE"
            echo "========================================"
            
            PREVIEW_NAMESPACE="preview-pr-$PR_NUMBER-$SERVICE"
            
            # Validate service structure
            echo "Validating service: $SERVICE"
            if [ ! -d "app/$SERVICE" ]; then
              echo "‚ùå Service directory app/$SERVICE not found"
              continue
            fi

            # Validate Kubernetes manifests (excluding kustomization files)
            if [ -d "app/$SERVICE/base" ]; then
              echo "Validating base manifests..."
              # Only validate actual Kubernetes resources, not kustomization files
              find app/$SERVICE/base -name "*.yaml" -not -name "kustomization.yaml" -exec kubectl apply --dry-run=client -f {} \; || {
                echo "‚ùå Base manifest validation failed for $SERVICE"
                continue
              }
            fi

            if [ -d "app/$SERVICE/overlays/dev" ]; then
              echo "Validating dev overlay..."
              cd app/$SERVICE/overlays/dev
              # Use kustomize to build and validate the final manifests
              if kustomize build . | kubectl apply --dry-run=client -f -; then
                echo "‚úÖ Dev overlay validation passed"
              else
                echo "‚ùå Dev overlay validation failed for $SERVICE"
                cd ../../../..
                continue
              fi
              cd ../../../..
            fi
            
            # Deploy to preview environment
            echo "Deploying $SERVICE to preview namespace: $PREVIEW_NAMESPACE"

            # Create preview namespace
            kubectl create namespace $PREVIEW_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

            # Wait for namespace to be ready
            echo "Waiting for namespace to be ready..."
            kubectl wait --for=condition=Ready namespace/$PREVIEW_NAMESPACE --timeout=30s || {
              echo "‚ö†Ô∏è Namespace may not be ready, but continuing..."
            }

            # Verify namespace exists
            kubectl get namespace $PREVIEW_NAMESPACE || {
              echo "‚ùå Namespace $PREVIEW_NAMESPACE not found, skipping deployment"
              continue
            }

            # Label for easy cleanup
            kubectl label namespace $PREVIEW_NAMESPACE \
              preview=true \
              pr-number=$PR_NUMBER \
              service=$SERVICE \
              created-by=github-actions

            # Deploy service to preview namespace
            echo "Deploying manifests to namespace: $PREVIEW_NAMESPACE"
            
            # Verify namespace exists before deploying
            if ! kubectl get namespace $PREVIEW_NAMESPACE >/dev/null 2>&1; then
              echo "‚ùå Namespace $PREVIEW_NAMESPACE not found, skipping deployment"
              continue
            fi
            
            if [ -d "app/$SERVICE/overlays/dev" ]; then
              echo "Using kustomize overlay for deployment..."
              cd app/$SERVICE/overlays/dev
              
              # Debug: show what kustomize builds
              echo "=== Kustomize build output ==="
              if ! kustomize build . > /tmp/kustomize-output.yaml; then
                echo "‚ùå Kustomize build failed"
                cd ../../../..
                continue
              fi
              
              cat /tmp/kustomize-output.yaml
              
              # Build with kustomize and set namespace
              echo "=== Applying with namespace replacement ==="
              
              # Remove any existing namespace field and apply to specific namespace
              if kustomize build . | \
                 yq eval 'del(.metadata.namespace)' - | \
                 kubectl apply -f - -n $PREVIEW_NAMESPACE; then
                echo "‚úÖ Kustomize deployment successful"
              else
                echo "‚ùå Kustomize deployment failed"
                echo "=== Kustomize output ==="
                kustomize build .
              fi
              
              cd ../../../..
            else
              echo "Using base manifests for deployment..."
              # Apply base manifests directly to preview namespace
              echo "=== Applying base manifests ==="
              
              for manifest_file in app/$SERVICE/base/*.yaml; do
                # Skip kustomization files
                if [[ "$manifest_file" == *"kustomization.yaml" ]]; then
                  continue
                fi
                
                echo "Applying: $manifest_file"
                if kubectl apply -f "$manifest_file" -n $PREVIEW_NAMESPACE; then
                  echo "‚úÖ Applied $manifest_file successfully"
                else
                  echo "‚ùå Failed to apply $manifest_file"
                fi
              done
            fi

            # Check if resources were actually created
            echo "=== Checking created resources ==="
            sleep 5  # Give time for resources to be created
            kubectl get all -n $PREVIEW_NAMESPACE
            
            # Count resources to verify deployment
            RESOURCE_COUNT=$(kubectl get all -n $PREVIEW_NAMESPACE --no-headers 2>/dev/null | wc -l)
            echo "Resource count in namespace: $RESOURCE_COUNT"
            
            if [ "$RESOURCE_COUNT" -gt 0 ]; then
              echo "‚úÖ Resources successfully deployed to $PREVIEW_NAMESPACE"
            else
              echo "‚ö†Ô∏è No resources found in $PREVIEW_NAMESPACE, but deployment may be in progress"
            fi
            
            # Show events if there are issues
            echo "=== Recent namespace events ==="
            kubectl get events -n $PREVIEW_NAMESPACE --sort-by='.lastTimestamp' | tail -10 || echo "No events found"

            # Wait for deployment to be ready
            echo "Waiting for deployment to be ready..."
            
            # Check if deployment exists first
            if kubectl get deployment -n $PREVIEW_NAMESPACE --no-headers 2>/dev/null | grep -q .; then
              kubectl wait --for=condition=available deployment --all -n $PREVIEW_NAMESPACE --timeout=300s || {
                echo "‚ö†Ô∏è Deployment may not be ready yet, but continuing..."
              }
            else
              echo "‚ö†Ô∏è No deployments found in namespace, skipping wait"
            fi
            
            # Show deployment status
            echo "Current deployment status:"
            kubectl get all -n $PREVIEW_NAMESPACE || echo "No resources found yet"
            
            # Generate preview domain
            echo "Generating domain for service: $SERVICE"
            DOMAIN_RESPONSE=$(curl -s -X POST "$DOMAIN_GENERATOR_URL/api/domains/generate" \
              -H "Content-Type: application/json" \
              -d "{
                \"serviceName\": \"$SERVICE\",
                \"namespace\": \"$PREVIEW_NAMESPACE\",
                \"internalService\": \"$INTERNAL_SERVICE_IP\",
                \"port\": $DOMAIN_PORT,
                \"useZeroTrust\": true,
                \"pullRequestId\": \"$PR_NUMBER\",
                \"branch\": \"$BRANCH_NAME\"
              }")

            echo "Domain API Response: $DOMAIN_RESPONSE"

            # Parse response
            SUCCESS=$(echo "$DOMAIN_RESPONSE" | jq -r '.success // false')
            PREVIEW_DOMAIN=$(echo "$DOMAIN_RESPONSE" | jq -r '.domain.full_domain // empty')
            PREVIEW_URL=$(echo "$DOMAIN_RESPONSE" | jq -r '.domain.url // empty')

            if [ "$SUCCESS" = "true" ] && [ -n "$PREVIEW_DOMAIN" ]; then
              # Parse domain ID from response
              DOMAIN_ID=$(echo "$DOMAIN_RESPONSE" | jq -r '.domain.id // empty')
              echo "‚úÖ Preview domain created: $PREVIEW_DOMAIN"
              echo "‚úÖ Preview URL: $PREVIEW_URL"
              echo "‚úÖ Domain ID: $DOMAIN_ID"
              
              # Store domain info for comment AND cleanup (include domain ID)
              echo "$SERVICE|$PREVIEW_DOMAIN|$PREVIEW_URL|$DOMAIN_ID" >> /tmp/preview-domains.txt
              
              # Also label the namespace with domain ID for cleanup
              kubectl label namespace $PREVIEW_NAMESPACE \
                domain-id=$DOMAIN_ID \
                --overwrite
            else
              echo "‚ùå Failed to create preview domain for $SERVICE"
              echo "API Response: $DOMAIN_RESPONSE"
              # Store fallback info (no domain ID)
              echo "$SERVICE|pr-$PR_NUMBER-$SERVICE.abdullahainun.site|https://pr-$PR_NUMBER-$SERVICE.abdullahainun.site|" >> /tmp/preview-domains.txt
            fi
            
            echo "‚úÖ Completed deployment for service: $SERVICE"
            echo ""
          done

  comment-preview:
    runs-on: self-hosted # Changed from ubuntu-latest
    needs: [detect-changes, preview-deploy]
    if: always() && github.event.action != 'closed' && needs.detect-changes.outputs.has-changes == 'true'

    steps:
      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const prNumber = ${{ github.event.number }};

            let comment = `## üöÄ Preview Environment Ready!\n\n`;
            comment += `Your services have been deployed to preview environments:\n\n`;

            // Read domain info from temp file
            let domainInfo = [];
            try {
              const domainData = fs.readFileSync('/tmp/preview-domains.txt', 'utf8');
              domainInfo = domainData.trim().split('\n').filter(line => line.length > 0);
            } catch (error) {
              console.log('No domain info file found, using fallback');
              // Fallback to services list
              const services = `${{ needs.detect-changes.outputs.services }}`.split(' ').filter(s => s);
              domainInfo = services.map(service => `${service}|pr-${prNumber}-${service}.abdullahainun.site|https://pr-${prNumber}-${service}.abdullahainun.site|`);
            }

            for (const line of domainInfo) {
              const [service, domain, url, domainId] = line.split('|');
              if (service && domain) {
                comment += `### üéØ ${service}\n`;
                comment += `- **Preview URL:** ${url || `https://${domain}`}\n`;
                comment += `- **Domain:** \`${domain}\`\n`;
                comment += `- **Namespace:** \`preview-pr-${prNumber}-${service}\`\n`;
                comment += `- **Auto-updates:** ‚úÖ (on new commits)\n`;
                comment += `- **Expires:** 24 hours\n\n`;
              }
            }

            comment += `### ‚ÑπÔ∏è Preview Info\n`;
            comment += `- üîÑ **Auto-updates** on every commit to this PR\n`;
            comment += `- üïê **Auto-expires** after 24 hours\n`;
            comment += `- üßπ **Auto-cleanup** when PR is closed\n`;
            comment += `- üîí **Zero Trust** protection enabled\n`;
            comment += `- üìä **Resource limits** applied for fair usage\n\n`;
            comment += `*Preview environments are automatically managed by our GitOps platform*`;

            github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  cleanup-preview:
    runs-on: self-hosted # Changed from ubuntu-latest
    if: github.event.action == 'closed'

    steps:
      # REMOVED: Setup kubectl steps - tidak perlu lagi!

      - name: Cleanup preview environments
        run: |
          PR_NUMBER="${{ github.event.number }}"

          echo "Cleaning up preview environments for PR #$PR_NUMBER"

          # Find all preview namespaces for this PR
          PREVIEW_NAMESPACES=$(kubectl get namespaces -l pr-number=$PR_NUMBER -o name 2>/dev/null || true)

          if [ -n "$PREVIEW_NAMESPACES" ]; then
            echo "Found preview namespaces: $PREVIEW_NAMESPACES"
            
            # Delete each namespace
            for ns in $PREVIEW_NAMESPACES; do
              echo "Deleting $ns..."
              kubectl delete $ns --ignore-not-found=true
            done
          else
            echo "No preview namespaces found for PR #$PR_NUMBER"
          fi

      - name: Cleanup preview domains
        run: |
          PR_NUMBER="${{ github.event.number }}"

          echo "Cleaning up preview domains for PR #$PR_NUMBER"

          # Find all preview namespaces for this PR and get domain IDs
          PREVIEW_NAMESPACES=$(kubectl get namespaces -l pr-number=$PR_NUMBER -o name 2>/dev/null || true)

          if [ -n "$PREVIEW_NAMESPACES" ]; then
            echo "Found preview namespaces: $PREVIEW_NAMESPACES"
            
            # Extract domain IDs from namespace labels and delete domains
            for ns in $PREVIEW_NAMESPACES; do
              NAMESPACE_NAME=$(echo $ns | cut -d'/' -f2)
              echo "Processing namespace: $NAMESPACE_NAME"
              
              # Get domain ID from namespace label
              DOMAIN_ID=$(kubectl get namespace $NAMESPACE_NAME -o jsonpath='{.metadata.labels.domain-id}' 2>/dev/null || echo "")
              
              if [ -n "$DOMAIN_ID" ] && [ "$DOMAIN_ID" != "" ]; then
                echo "Deleting domain ID: $DOMAIN_ID"
                
                # Delete domain using correct API endpoint
                CLEANUP_RESPONSE=$(curl -s -X DELETE "$DOMAIN_GENERATOR_URL/api/domains/$DOMAIN_ID" \
                  -H "Content-Type: application/json")
                
                echo "Domain deletion response: $CLEANUP_RESPONSE"
                
                # Check if cleanup was successful
                SUCCESS=$(echo "$CLEANUP_RESPONSE" | jq -r '.success // false' 2>/dev/null || echo "false")
                
                if [ "$SUCCESS" = "true" ]; then
                  echo "‚úÖ Domain ID $DOMAIN_ID deleted successfully"
                else
                  echo "‚ö†Ô∏è Domain deletion response for ID $DOMAIN_ID: $CLEANUP_RESPONSE"
                fi
              else
                echo "‚ö†Ô∏è No domain ID found for namespace $NAMESPACE_NAME"
              fi
              
              # Delete the namespace
              echo "Deleting namespace: $ns"
              kubectl delete $ns --ignore-not-found=true
            done
          else
            echo "No preview namespaces found for PR #$PR_NUMBER"
          fi

      - name: Comment cleanup
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ github.event.number }};
            const comment = `## üßπ Preview Environment Cleaned Up\n\n` +
              `All preview resources for this PR have been automatically removed:\n\n` +
              `- ‚úÖ Preview namespaces deleted\n` +
              `- ‚úÖ Preview domains removed\n` +
              `- ‚úÖ All resources cleaned up\n\n` +
              `Thank you for contributing! üôè`;

            github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  production-deploy:
    runs-on: self-hosted # Changed from ubuntu-latest
    needs: detect-changes
    if: github.event.action == 'closed' && github.event.pull_request.merged == true && needs.detect-changes.outputs.has-changes == 'true'

    steps:
      - name: Trigger production deployment
        run: |
          echo "PR merged! Production deployment will be handled by Flux CD"
          echo "Services will be deployed via regular GitOps flow"

      - name: Comment production deployment
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ github.event.number }};
            const comment = `## üéâ Merged to Production!\n\n` +
              `Your contribution has been merged and will be deployed to production via Flux CD.\n\n` +
              `### What happens next:\n` +
              `- üîÑ Flux CD will deploy your service to production namespace\n` +
              `- üåê Permanent domain will be generated\n` +
              `- üìä Service will appear in the public catalog\n` +
              `- ‚ú® Community can discover and use your service\n\n` +
              `**Estimated production deployment time:** 2-5 minutes\n\n` +
              `Thank you for your contribution! üöÄ`;

            github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
