# .github/workflows/pr-preview-comment.yml
name: PR Preview Environment (Comment Triggered)

on:
  issue_comment:
    types: [created]
  pull_request:
    types: [closed]
    paths:
      - "apps/**"
      - "clusters/homelab/03-community/**"

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: read

env:
  DOMAIN_GENERATOR_URL: "https://dg.homelab.local"

jobs:
  # Parse comment commands
  parse-command:
    runs-on: self-hosted
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    outputs:
      command: ${{ steps.parse.outputs.command }}
      environment: ${{ steps.parse.outputs.environment }}
      service: ${{ steps.parse.outputs.service }}
      allowed: ${{ steps.check-permissions.outputs.allowed }}
    steps:
      - name: Check command type and permissions
        id: check-permissions
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `${{ github.event.comment.body }}`;
            const user = context.actor;
            const coreTeam = ['abdullahainun']; // Repository owner/maintainer
            
            console.log(`Checking permissions for user: ${user}`);
            console.log(`Command: ${comment}`);
            
            // Commands yang aman untuk semua orang (read-only)
            const safeCommands = ['/help', '/status', '/plan'];
            const isSafeCommand = safeCommands.some(cmd => comment.trim().startsWith(cmd));
            
            if (isSafeCommand) {
              console.log(`Safe command detected, allowing all users: ${comment}`);
              core.setOutput('allowed', 'true');
              core.setOutput('command-type', 'safe');
              return;
            }
            
            // Deployment commands hanya untuk core team atau trusted collaborators
            const deployCommands = ['/preview', '/cleanup'];
            const isDeployCommand = deployCommands.some(cmd => comment.trim().startsWith(cmd));
            
            if (isDeployCommand) {
              console.log(`Deploy command detected: ${comment}`);
              
              // Core team selalu diizinkan
              if (coreTeam.includes(user)) {
                console.log(`User ${user} is in core team`);
                core.setOutput('allowed', 'true');
                core.setOutput('command-type', 'deploy');
                return;
              }
              
              // Check repository permissions untuk yang lain
              try {
                const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  username: user
                });
                
                const hasPermission = ['admin', 'write'].includes(permission.permission);
                console.log(`User ${user} has repository permission: ${permission.permission}, allowed: ${hasPermission}`);
                
                if (hasPermission) {
                  core.setOutput('allowed', 'true');
                  core.setOutput('command-type', 'deploy');
                } else {
                  core.setOutput('allowed', 'false');
                  core.setOutput('command-type', 'deploy-denied');
                }
              } catch (error) {
                console.log(`Error checking repository permissions: ${error.message}`);
                core.setOutput('allowed', 'false');
                core.setOutput('command-type', 'deploy-denied');
              }
            } else {
              console.log(`Unknown command: ${comment}`);
              core.setOutput('allowed', 'false');
              core.setOutput('command-type', 'unknown');
            }

      - name: React to comment based on permission
        uses: actions/github-script@v7
        with:
          script: |
            const commandType = '${{ steps.check-permissions.outputs.command-type }}';
            const allowed = '${{ steps.check-permissions.outputs.allowed }}';
            
            if (allowed === 'true') {
              // React with eyes emoji untuk semua command yang diizinkan
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'eyes'
              });
            } else if (commandType === 'deploy-denied') {
              // React with confused emoji untuk deployment yang ditolak
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'confused'
              });
            }

      - name: Parse comment commands
        id: parse
        if: steps.check-permissions.outputs.allowed == 'true'
        run: |
          comment="${{ github.event.comment.body }}"
          echo "Parsing comment: $comment"
          
          # Default values
          echo "command=" >> $GITHUB_OUTPUT
          echo "environment=dev" >> $GITHUB_OUTPUT
          echo "service=" >> $GITHUB_OUTPUT
          
          # Parse different command patterns
          if [[ "$comment" =~ ^/preview[[:space:]]*$ ]]; then
            echo "command=preview" >> $GITHUB_OUTPUT
            
          elif [[ "$comment" =~ ^/preview[[:space:]]+([a-zA-Z0-9/-]+)[[:space:]]*$ ]]; then
            echo "command=preview" >> $GITHUB_OUTPUT
            echo "service=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
            
          elif [[ "$comment" =~ ^/preview[[:space:]]+([a-zA-Z0-9/-]+)[[:space:]]+([a-zA-Z0-9-]+)[[:space:]]*$ ]]; then
            echo "command=preview" >> $GITHUB_OUTPUT
            echo "service=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
            echo "environment=${BASH_REMATCH[2]}" >> $GITHUB_OUTPUT
            
          elif [[ "$comment" =~ ^/plan[[:space:]]*$ ]]; then
            echo "command=plan" >> $GITHUB_OUTPUT
            
          elif [[ "$comment" =~ ^/plan[[:space:]]+([a-zA-Z0-9/-]+)[[:space:]]*$ ]]; then
            echo "command=plan" >> $GITHUB_OUTPUT
            echo "service=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
            
          elif [[ "$comment" =~ ^/cleanup[[:space:]]*$ ]]; then
            echo "command=cleanup" >> $GITHUB_OUTPUT
            
          elif [[ "$comment" =~ ^/status[[:space:]]*$ ]]; then
            echo "command=status" >> $GITHUB_OUTPUT
            
          elif [[ "$comment" =~ ^/help[[:space:]]*$ ]]; then
            echo "command=help" >> $GITHUB_OUTPUT
          fi

      - name: Show help
        if: steps.parse.outputs.command == 'help'
        uses: actions/github-script@v7
        with:
          script: |
            const user = context.actor;
            const coreTeam = ['abdullahainun'];
            const isCore = coreTeam.includes(user);
            
            let helpText = `## ðŸ¤– Available Commands

            **ðŸ“– Read-Only Commands (Available to Everyone):**
            - \`/help\` - Show this help message
            - \`/status\` - Show current preview environments  
            - \`/plan\` - Show what would be deployed (dry-run)
            - \`/plan <service>\` - Show plan for specific service (e.g., \`/plan ai/open-webui\`)

            **Examples:**
            \`\`\`
            /help
            /status  
            /plan
            /plan ai/open-webui
            \`\`\`
            `;

            if (isCore) {
              helpText += `
            **ðŸš€ Deployment Commands (Core Team & Collaborators Only):**
            - \`/preview\` - Deploy all changed services to preview
            - \`/preview <service>\` - Deploy specific service (e.g., \`/preview ai/open-webui\`)
            - \`/preview <service> <env>\` - Deploy to specific environment (e.g., \`/preview ai/open-webui staging\`)
            - \`/cleanup\` - Manually cleanup preview environments

            **Deployment Examples:**
            \`\`\`
            /preview
            /preview ai/open-webui
            /preview ai/open-webui staging
            /cleanup
            \`\`\`
            `;
            } else {
              helpText += `
            **ðŸ”’ Deployment Commands:**
            - Available only to repository maintainers and collaborators with write access
            - If you're a trusted contributor, request write access from @abdullahainun
            - Core team can use: \`/preview\`, \`/cleanup\` commands
            `;
            }

            helpText += `
            **ðŸ›¡ï¸ Permission System:**
            - **Everyone:** Can use read-only commands (\`/help\`, \`/status\`, \`/plan\`)
            - **Core Team:** @abdullahainun (full access)
            - **Collaborators:** Users with repository write access can deploy
            - **External Contributors:** Read-only access for safety

            **ðŸ  About This Homelab:**
            This is a public homelab repository where the community can:
            - ðŸ‘€ View and learn from the setup
            - ðŸ“‹ Plan deployments to understand the infrastructure  
            - ðŸ¤ Contribute improvements via PRs
            - ðŸš€ Trusted contributors can test deployments

            **Need deployment access?** Contact @abdullahainun or contribute regularly to gain write access!`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: helpText
            });

      - name: Handle unauthorized deployment attempts
        if: steps.check-permissions.outputs.command-type == 'deploy-denied'
        uses: actions/github-script@v7
        with:
          script: |
            const user = context.actor;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸ”’ **Access Denied for @${user}**\n\n` +
                    `Sorry, you don't have permission to trigger deployments in this repository.\n\n` +
                    `**Available options:**\n` +
                    `- ðŸ“‹ Use \`/plan\` to see what would be deployed (read-only)\n` +
                    `- ðŸ“Š Use \`/status\` to check current preview environments\n` +
                    `- ðŸ“– Use \`/help\` to see all available commands\n\n` +
                    `**Want deployment access?**\n` +
                    `- Become a regular contributor to gain write access\n` +
                    `- Contact @abdullahainun for collaboration opportunities\n` +
                    `- Repository collaborators with write access can deploy\n\n` +
                    `*This restriction helps protect the homelab infrastructure while keeping the repository public for learning and collaboration.*`
            });

      - name: Handle unknown commands  
        if: steps.check-permissions.outputs.command-type == 'unknown'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `â“ **Unknown Command**\n\n` +
                    `I didn't recognize that command. Use \`/help\` to see all available commands!\n\n` +
                    `**Quick commands:**\n` +
                    `- \`/help\` - Show all available commands\n` +
                    `- \`/plan\` - Show deployment plan\n` +
                    `- \`/status\` - Check preview environments`
            });

  # Detect changes (for preview and plan commands)
  detect-changes:
    runs-on: self-hosted
    needs: parse-command
    if: needs.parse-command.outputs.allowed == 'true' && (needs.parse-command.outputs.command == 'preview' || needs.parse-command.outputs.command == 'plan' || needs.parse-command.outputs.command == 'status')
    outputs:
      services: ${{ steps.changes.outputs.services }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
      pr-ref: ${{ steps.pr-info.outputs.ref }}
      pr-sha: ${{ steps.pr-info.outputs.sha }}
    steps:
      - name: Get PR information
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            core.setOutput('ref', pr.data.head.ref);
            core.setOutput('sha', pr.data.head.sha);
            return pr.data;

      - uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-info.outputs.ref }}
          fetch-depth: 0

      - name: Detect changed services
        id: changes
        run: |
          SPECIFIC_SERVICE="${{ needs.parse-command.outputs.service }}"
          
          if [ -n "$SPECIFIC_SERVICE" ]; then
            # User specified a specific service
            echo "Using specified service: $SPECIFIC_SERVICE"
            echo "services=$SPECIFIC_SERVICE" >> $GITHUB_OUTPUT
            echo "has-changes=true" >> $GITHUB_OUTPUT
          else
            # Auto-detect changed services
            CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
            echo "Changed files: $CHANGED_FILES"

            # Extract service names from changed paths
            SERVICES=$(echo "$CHANGED_FILES" | grep -E '^apps/[^/]+/[^/]+/' | cut -d'/' -f2,3 | sort | uniq | tr '\n' ' ')
            COMMUNITY_REFS=$(echo "$CHANGED_FILES" | grep -E '^clusters/homelab/03-community/' | sed 's|.*/||' | sed 's|\.yaml$||' | tr '\n' ' ')

            # Combine and deduplicate
            ALL_SERVICES=$(echo "$SERVICES $COMMUNITY_REFS" | tr ' ' '\n' | sort | uniq | tr '\n' ' ')
            ALL_SERVICES_TRIMMED=$(echo "$ALL_SERVICES" | sed 's/^ *//;s/ *$//')

            echo "services=$ALL_SERVICES_TRIMMED" >> $GITHUB_OUTPUT
            if [ -n "$ALL_SERVICES_TRIMMED" ]; then
              echo "has-changes=true" >> $GITHUB_OUTPUT
            else
              echo "has-changes=false" >> $GITHUB_OUTPUT
            fi

            echo "Detected services: $ALL_SERVICES_TRIMMED"
          fi

  # Plan command - show what would be deployed (available for everyone)
  plan-preview:
    runs-on: self-hosted
    needs: [parse-command, detect-changes]
    if: needs.parse-command.outputs.command == 'plan' && needs.detect-changes.outputs.has-changes == 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-changes.outputs.pr-ref }}

      - name: Plan deployment
        id: plan
        run: |
          SERVICES="${{ needs.detect-changes.outputs.services }}"
          PR_NUMBER="${{ github.event.issue.number }}"
          ENVIRONMENT="${{ needs.parse-command.outputs.environment }}"
          
          echo "## ðŸ“‹ Deployment Plan" > /tmp/plan-output.md
          echo "" >> /tmp/plan-output.md
          echo "**ðŸ‘¤ Requested by:** @${{ github.actor }}" >> /tmp/plan-output.md
          echo "**ðŸŽ¯ Services to deploy:** $SERVICES" >> /tmp/plan-output.md
          echo "**ðŸŒ Target environment:** $ENVIRONMENT" >> /tmp/plan-output.md
          echo "**ðŸ”— PR:** #$PR_NUMBER" >> /tmp/plan-output.md
          echo "" >> /tmp/plan-output.md
          
          for SERVICE_PATH in $SERVICES; do
            echo "### ðŸ“¦ Service: $SERVICE_PATH" >> /tmp/plan-output.md
            echo "" >> /tmp/plan-output.md
            
            SERVICE_NAMESPACE_NAME=$(echo "$SERVICE_PATH" | tr '/' '-')
            PREVIEW_NAMESPACE="preview-pr-$PR_NUMBER-$SERVICE_NAMESPACE_NAME"
            
            echo "- **Namespace:** \`$PREVIEW_NAMESPACE\`" >> /tmp/plan-output.md
            
            # Check service structure
            if [ ! -d "apps/$SERVICE_PATH" ]; then
              echo "- **Status:** âŒ Service directory not found" >> /tmp/plan-output.md
              continue
            fi

            if [ -d "apps/$SERVICE_PATH/base" ]; then
              echo "- **Base manifests:** âœ… Found at \`apps/$SERVICE_PATH/base\`" >> /tmp/plan-output.md
              BASE_DIR="apps/$SERVICE_PATH/base"
            else
              echo "- **Base manifests:** âŒ No base directory found" >> /tmp/plan-output.md
              continue
            fi

            OVERLAY_DIR=""
            if [ -d "apps/$SERVICE_PATH/overlays/$ENVIRONMENT" ]; then
              echo "- **Environment overlay:** âœ… Found \`$ENVIRONMENT\` overlay" >> /tmp/plan-output.md
              OVERLAY_DIR="apps/$SERVICE_PATH/overlays/$ENVIRONMENT"
            else
              echo "- **Environment overlay:** âš ï¸ No \`$ENVIRONMENT\` overlay, using base only" >> /tmp/plan-output.md
            fi

            # Dry run validation
            echo "" >> /tmp/plan-output.md
            echo "**Validation Results:**" >> /tmp/plan-output.md
            echo '```' >> /tmp/plan-output.md
            
            if [ -n "$OVERLAY_DIR" ]; then
              cd "$OVERLAY_DIR"
              if kustomize build . | kubectl apply --dry-run=client -f - 2>&1; then
                echo "âœ… Kustomize validation passed" >> /tmp/plan-output.md
              else
                echo "âŒ Kustomize validation failed" >> /tmp/plan-output.md
              fi
              cd - > /dev/null
            else
              find "$BASE_DIR" -name "*.yaml" -not -name "kustomization.yaml" -exec kubectl apply --dry-run=client -f {} \; 2>&1 | head -10 >> /tmp/plan-output.md
            fi
            
            echo '```' >> /tmp/plan-output.md
            echo "" >> /tmp/plan-output.md
            
            # Preview URLs
            echo "**Preview URLs:**" >> /tmp/plan-output.md
            echo "- **Domain:** \`pr-$PR_NUMBER-$SERVICE_NAMESPACE_NAME.abdullahainun.site\`" >> /tmp/plan-output.md
            echo "- **URL:** \`https://pr-$PR_NUMBER-$SERVICE_NAMESPACE_NAME.abdullahainun.site\`" >> /tmp/plan-output.md
            echo "" >> /tmp/plan-output.md
          done
          
          echo "" >> /tmp/plan-output.md
          echo "**ðŸš€ Next steps:**" >> /tmp/plan-output.md
          
          # Check if user can deploy
          USER="${{ github.actor }}"
          CORE_TEAM="abdullahainun"
          
          if [ "$USER" = "$CORE_TEAM" ]; then
            echo "- Run \`/preview\` to deploy these services" >> /tmp/plan-output.md
            echo "- Run \`/preview <service>\` to deploy a specific service" >> /tmp/plan-output.md  
            echo "- Run \`/preview <service> <env>\` to deploy to a specific environment" >> /tmp/plan-output.md
          else
            echo "- â„¹ï¸ Only @abdullahainun and collaborators with write access can deploy" >> /tmp/plan-output.md
            echo "- ðŸ¤ Want to deploy? Become a trusted contributor or request write access" >> /tmp/plan-output.md
            echo "- ðŸ“– This plan shows what would happen if deployment was triggered" >> /tmp/plan-output.md
          fi
          
          echo "" >> /tmp/plan-output.md
          echo "*This plan is read-only and safe for everyone to use. No infrastructure changes will be made.*" >> /tmp/plan-output.md

      - name: Comment plan results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('/tmp/plan-output.md', 'utf8');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: plan
            });

  # Main preview deployment
  preview-deploy:
    runs-on: self-hosted
    needs: [parse-command, detect-changes]
    if: needs.parse-command.outputs.command == 'preview' && needs.detect-changes.outputs.has-changes == 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-changes.outputs.pr-ref }}

      - name: Notify deployment start
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'ðŸš€ **Starting preview deployment...**\n\nDeploying services: `${{ needs.detect-changes.outputs.services }}`\n\nThis may take a few minutes. I\'ll update you when it\'s ready! â³'
            });

      - name: Deploy services to preview
        run: |
          SERVICES="${{ needs.detect-changes.outputs.services }}"
          PR_NUMBER="${{ github.event.issue.number }}"
          BRANCH_NAME="${{ needs.detect-changes.outputs.pr-ref }}"
          ENVIRONMENT="${{ needs.parse-command.outputs.environment }}"

          echo "Services to deploy: $SERVICES"
          echo "PR Number: $PR_NUMBER"
          echo "Branch: $BRANCH_NAME"
          echo "Environment: $ENVIRONMENT"

          # Initialize temp file for domain info
          > /tmp/preview-domains.txt

          # Process each service
          for SERVICE_PATH in $SERVICES; do
            echo "========================================"
            echo "Processing service path: $SERVICE_PATH"
            echo "========================================"
            
            # Extract category and service name
            CATEGORY=$(echo "$SERVICE_PATH" | cut -d'/' -f1)
            SERVICE_NAME=$(echo "$SERVICE_PATH" | cut -d'/' -f2)
            
            # Create sanitized namespace name
            SERVICE_NAMESPACE_NAME=$(echo "$SERVICE_PATH" | tr '/' '-')
            PREVIEW_NAMESPACE="preview-pr-$PR_NUMBER-$SERVICE_NAMESPACE_NAME"
            
            echo "Category: $CATEGORY"
            echo "Service Name: $SERVICE_NAME"
            echo "Namespace: $PREVIEW_NAMESPACE"
            echo "Environment: $ENVIRONMENT"
            
            # Validate service structure
            if [ ! -d "apps/$SERVICE_PATH" ]; then
              echo "âŒ Service directory apps/$SERVICE_PATH not found"
              continue
            fi

            # Check for base directory
            if [ -d "apps/$SERVICE_PATH/base" ]; then
              BASE_DIR="apps/$SERVICE_PATH/base"
            else
              echo "âŒ No base directory found at apps/$SERVICE_PATH/base"
              continue
            fi

            # Check for overlay directory
            OVERLAY_DIR=""
            if [ -d "apps/$SERVICE_PATH/overlays/$ENVIRONMENT" ]; then
              OVERLAY_DIR="apps/$SERVICE_PATH/overlays/$ENVIRONMENT"
            fi

            # Create preview namespace
            kubectl create namespace $PREVIEW_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

            # Label for easy cleanup
            kubectl label namespace $PREVIEW_NAMESPACE \
              preview=true \
              pr-number=$PR_NUMBER \
              service="$SERVICE_NAMESPACE_NAME" \
              environment="$ENVIRONMENT" \
              created-by=github-actions \
              --overwrite

            # Deploy service to preview namespace
            DEPLOYMENT_SUCCESS=false
            
            if [ -n "$OVERLAY_DIR" ]; then
              cd "$OVERLAY_DIR"
              KUSTOMIZE_OUTPUT=$(kustomize build . 2>&1)
              if [ $? -eq 0 ]; then
                echo "$KUSTOMIZE_OUTPUT" | yq eval 'del(.metadata.namespace)' - | kubectl apply -f - -n $PREVIEW_NAMESPACE
                if [ $? -eq 0 ]; then
                  DEPLOYMENT_SUCCESS=true
                fi
              fi
              cd - > /dev/null
            else
              find "$BASE_DIR" -name "*.yaml" -not -name "kustomization.yaml" -exec kubectl apply -f {} -n $PREVIEW_NAMESPACE \;
              if [ $? -eq 0 ]; then
                DEPLOYMENT_SUCCESS=true
              fi
            fi

            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              echo "$SERVICE_PATH|DEPLOYMENT_FAILED|Deployment to namespace failed|||" >> /tmp/preview-domains.txt
              continue
            fi

            # Wait for deployment
            sleep 15
            kubectl wait --for=condition=available deployment --all -n $PREVIEW_NAMESPACE --timeout=300s || true

            # Extract service information
            SERVICE_INFO=$(kubectl get service -n $PREVIEW_NAMESPACE -o json 2>/dev/null | jq -r '.items[0] // empty')
            
            if [ -n "$SERVICE_INFO" ] && [ "$SERVICE_INFO" != "null" ]; then
              ACTUAL_SERVICE_NAME=$(echo "$SERVICE_INFO" | jq -r '.metadata.name')
              ACTUAL_SERVICE_PORT=$(echo "$SERVICE_INFO" | jq -r '.spec.ports[0].port // 80')
              
              # Generate preview domain
              DOMAIN_RESPONSE=$(curl -s -X POST "$DOMAIN_GENERATOR_URL/api/domains/generate" \
                -H "Content-Type: application/json" \
                -d "{
                  \"serviceName\": \"$SERVICE_NAMESPACE_NAME\",
                  \"namespace\": \"$PREVIEW_NAMESPACE\",
                  \"internalService\": \"${ACTUAL_SERVICE_NAME}.${PREVIEW_NAMESPACE}\",
                  \"port\": $ACTUAL_SERVICE_PORT,
                  \"useZeroTrust\": true,
                  \"pullRequestId\": \"$PR_NUMBER\",
                  \"branch\": \"$BRANCH_NAME\"
                }")

              SUCCESS=$(echo "$DOMAIN_RESPONSE" | jq -r '.success // false')
              PREVIEW_DOMAIN=$(echo "$DOMAIN_RESPONSE" | jq -r '.domain.full_domain // empty')
              PREVIEW_URL=$(echo "$DOMAIN_RESPONSE" | jq -r '.domain.url // empty')

              if [ "$SUCCESS" = "true" ] && [ -n "$PREVIEW_DOMAIN" ]; then
                DOMAIN_ID=$(echo "$DOMAIN_RESPONSE" | jq -r '.domain.id // empty')
                echo "$SERVICE_PATH|$PREVIEW_DOMAIN|$PREVIEW_URL|$DOMAIN_ID|$ACTUAL_SERVICE_NAME|$ACTUAL_SERVICE_PORT" >> /tmp/preview-domains.txt
                
                kubectl label namespace $PREVIEW_NAMESPACE domain-id=$DOMAIN_ID --overwrite
              else
                echo "$SERVICE_PATH|pr-$PR_NUMBER-$SERVICE_NAMESPACE_NAME.abdullahainun.site|https://pr-$PR_NUMBER-$SERVICE_NAMESPACE_NAME.abdullahainun.site||$ACTUAL_SERVICE_NAME|$ACTUAL_SERVICE_PORT" >> /tmp/preview-domains.txt
              fi
            else
              echo "$SERVICE_PATH|NO_SERVICE_FOUND|No Kubernetes Service found|||" >> /tmp/preview-domains.txt
            fi
          done

  # Comment with results
  comment-preview:
    runs-on: self-hosted
    needs: [parse-command, detect-changes, preview-deploy]
    if: always() && needs.parse-command.outputs.command == 'preview' && needs.detect-changes.outputs.has-changes == 'true'
    steps:
      - name: Comment deployment results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const prNumber = ${{ github.event.issue.number }};

            let comment = `## ðŸš€ Preview Deployment Results\n\n`;

            // Read domain info
            let domainInfo = [];
            try {
              const domainData = fs.readFileSync('/tmp/preview-domains.txt', 'utf8');
              domainInfo = domainData.trim().split('\n').filter(line => line.length > 0);
            } catch (error) {
              comment += `### âŒ Deployment Failed\n\nCould not find deployment results. Please check the workflow logs.`;
              
              await github.rest.issues.createComment({
                issue_number: prNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              return;
            }

            let hasSuccess = false;
            let hasFailure = false;

            for (const line of domainInfo) {
              const [servicePath, domain, url, domainId, serviceName, servicePort] = line.split('|');
              
              if (domain === 'DEPLOYMENT_FAILED' || domain === 'NO_SERVICE_FOUND') {
                hasFailure = true;
                comment += `### âŒ ${servicePath} - Failed\n`;
                comment += `**Error:** ${url || domain}\n\n`;
              } else if (domain) {
                hasSuccess = true;
                const namespaceFormatted = servicePath.replace('/', '-');
                const previewNamespace = `preview-pr-${prNumber}-${namespaceFormatted}`;
                
                comment += `### âœ… ${servicePath} - Deployed\n`;
                comment += `- **Preview URL:** ${url || `https://${domain}`}\n`;
                comment += `- **Domain:** \`${domain}\`\n`;
                comment += `- **Namespace:** \`${previewNamespace}\`\n`;
                if (serviceName && servicePort) {
                  comment += `- **Service:** \`${serviceName}:${servicePort}\`\n`;
                }
                comment += `\n`;
              }
            }

            if (hasSuccess) {
              comment += `### ðŸ“ Available Commands\n`;
              comment += `- \`/status\` - Check current preview environments\n`;
              comment += `- \`/cleanup\` - Manually cleanup preview environments\n`;
              comment += `- \`/plan\` - Show deployment plan\n`;
              comment += `- \`/help\` - Show all available commands\n\n`;
            }

            comment += `*Triggered by: @${context.actor}*`;

            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Show status command
  show-status:
    runs-on: self-hosted
    needs: parse-command
    if: needs.parse-command.outputs.command == 'status'
    steps:
      - name: Get preview status
        run: |
          PR_NUMBER="${{ github.event.issue.number }}"
          
          echo "## ðŸ“Š Preview Environment Status" > /tmp/status-output.md
          echo "" >> /tmp/status-output.md
          echo "**PR:** #$PR_NUMBER" >> /tmp/status-output.md
          echo "" >> /tmp/status-output.md
          
          # Find preview namespaces for this PR
          PREVIEW_NAMESPACES=$(kubectl get namespaces -l pr-number=$PR_NUMBER -o custom-columns=NAME:.metadata.name,SERVICE:.metadata.labels.service,CREATED:.metadata.creationTimestamp --no-headers 2>/dev/null || true)
          
          if [ -n "$PREVIEW_NAMESPACES" ]; then
            echo "### ðŸŸ¢ Active Preview Environments" >> /tmp/status-output.md
            echo "" >> /tmp/status-output.md
            
            echo "$PREVIEW_NAMESPACES" | while read namespace service created; do
              if [ -n "$namespace" ]; then
                echo "#### $service" >> /tmp/status-output.md
                echo "- **Namespace:** \`$namespace\`" >> /tmp/status-output.md
                echo "- **Created:** $created" >> /tmp/status-output.md
                
                # Get domain info
                DOMAIN_ID=$(kubectl get namespace $namespace -o jsonpath='{.metadata.labels.domain-id}' 2>/dev/null || echo "")
                if [ -n "$DOMAIN_ID" ]; then
                curl -s -X DELETE "$DOMAIN_GENERATOR_URL/api/domains/$DOMAIN_ID" \
                  -H "Content-Type: application/json"
              fi
              
              # Delete namespace
              kubectl delete $ns --ignore-not-found=true
            done
            
            echo "CLEANUP_SUCCESS=true" >> $GITHUB_ENV
            echo "CLEANED_NAMESPACES=$PREVIEW_NAMESPACES" >> $GITHUB_ENV
          else
            echo "CLEANUP_SUCCESS=false" >> $GITHUB_ENV
            echo "No preview namespaces found for cleanup"
          fi

      - name: Comment cleanup result
        uses: actions/github-script@v7
        with:
          script: |
            const success = process.env.CLEANUP_SUCCESS === 'true';
            const cleanedNamespaces = process.env.CLEANED_NAMESPACES || '';
            
            let comment;
            if (success) {
              const namespaceList = cleanedNamespaces.split(' ').map(ns => `- \`${ns.replace('namespace/', '')}\``).join('\n');
              
              comment = `## ðŸ§¹ Manual Cleanup Completed\n\n` +
                `Successfully cleaned up preview environments:\n\n${namespaceList}\n\n` +
                `- âœ… Preview domains removed\n` +
                `- âœ… Kubernetes namespaces deleted\n` +
                `- âœ… All resources cleaned up\n\n` +
                `*Cleanup triggered by: @${context.actor}*`;
            } else {
              comment = `## â„¹ï¸ Manual Cleanup - Nothing to Clean\n\n` +
                `No preview environments were found for this PR.\n\n` +
                `All preview resources appear to already be cleaned up.\n\n` +
                `*Cleanup triggered by: @${context.actor}*`;
            }
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Auto cleanup when PR is closed
  cleanup-preview:
    runs-on: self-hosted
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    steps:
      - name: Cleanup preview environments
        run: |
          PR_NUMBER="${{ github.event.number }}"

          echo "Auto-cleaning up preview environments for PR #$PR_NUMBER"

          # Find all preview namespaces for this PR
          PREVIEW_NAMESPACES=$(kubectl get namespaces -l pr-number=$PR_NUMBER -o name 2>/dev/null || true)

          if [ -n "$PREVIEW_NAMESPACES" ]; then
            echo "Found preview namespaces: $PREVIEW_NAMESPACES"
            
            # Extract domain IDs and delete domains first
            for ns in $PREVIEW_NAMESPACES; do
              NAMESPACE_NAME=$(echo $ns | cut -d'/' -f2)
              echo "Processing namespace: $NAMESPACE_NAME"
              
              DOMAIN_ID=$(kubectl get namespace $NAMESPACE_NAME -o jsonpath='{.metadata.labels.domain-id}' 2>/dev/null || echo "")
              
              if [ -n "$DOMAIN_ID" ] && [ "$DOMAIN_ID" != "" ]; then
                echo "Deleting domain ID: $DOMAIN_ID"
                CLEANUP_RESPONSE=$(curl -s -X DELETE "$DOMAIN_GENERATOR_URL/api/domains/$DOMAIN_ID" \
                  -H "Content-Type: application/json")
                echo "Domain deletion response: $CLEANUP_RESPONSE"
              fi
              
              echo "Deleting namespace: $ns"
              kubectl delete $ns --ignore-not-found=true
            done
          else
            echo "No preview namespaces found for PR #$PR_NUMBER"
          fi

      - name: Comment auto cleanup
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ github.event.number }};
            const comment = `## ðŸ§¹ Preview Environment Auto-Cleanup\n\n` +
              `All preview resources for this PR have been automatically removed:\n\n` +
              `- âœ… Preview namespaces deleted\n` +
              `- âœ… Preview domains removed\n` +
              `- âœ… All resources cleaned up\n\n` +
              `Thank you for contributing! ðŸ™`;

            github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Production deployment when PR is merged
  production-deploy:
    runs-on: self-hosted
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect merged changes
        id: changes
        run: |
          # Detect which services were changed in the merged PR
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files in merge: $CHANGED_FILES"

          # Extract service names from changed paths
          SERVICES=$(echo "$CHANGED_FILES" | grep -E '^apps/[^/]+/[^/]+/' | cut -d'/' -f2,3 | sort | uniq | tr '\n' ' ')
          COMMUNITY_REFS=$(echo "$CHANGED_FILES" | grep -E '^clusters/homelab/03-community/' | sed 's|.*/||' | sed 's|\.yaml$||' | tr '\n' ' ')

          # Combine and deduplicate
          ALL_SERVICES=$(echo "$SERVICES $COMMUNITY_REFS" | tr ' ' '\n' | sort | uniq | tr '\n' ' ')
          ALL_SERVICES_TRIMMED=$(echo "$ALL_SERVICES" | sed 's/^ *//;s/ *$//')

          echo "services=$ALL_SERVICES_TRIMMED" >> $GITHUB_OUTPUT
          if [ -n "$ALL_SERVICES_TRIMMED" ]; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "Detected merged services: $ALL_SERVICES_TRIMMED"
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "No service changes detected in merge"
          fi

      - name: Trigger production deployment
        if: steps.changes.outputs.has-changes == 'true'
        run: |
          SERVICES="${{ steps.changes.outputs.services }}"
          echo "PR merged! Services to be deployed to production: $SERVICES"
          echo "Services will be deployed via Flux CD GitOps flow"
          
          # Optional: Trigger flux reconciliation for faster deployment
          # flux reconcile source git homelab-k8s || echo "Flux reconcile failed, but GitOps will eventually sync"

      - name: Comment production deployment
        if: steps.changes.outputs.has-changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ github.event.number }};
            const services = '${{ steps.changes.outputs.services }}';
            
            const comment = `## ðŸŽ‰ Merged to Production!\n\n` +
              `Your contribution has been merged and will be deployed to production via Flux CD.\n\n` +
              `**Services being deployed:** ${services}\n\n` +
              `### What happens next:\n` +
              `- ðŸ”„ Flux CD will deploy your services to production namespaces\n` +
              `- ðŸŒ Permanent domains will be generated\n` +
              `- ðŸ“Š Services will appear in the public catalog\n` +
              `- âœ¨ Community can discover and use your services\n\n` +
              `**Estimated production deployment time:** 2-5 minutes\n\n` +
              `Monitor deployment status in your cluster dashboard.\n\n` +
              `Thank you for your contribution! ðŸš€`;

            github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: No changes to deploy
        if: steps.changes.outputs.has-changes == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ github.event.number }};
            
            const comment = `## âœ… PR Merged Successfully\n\n` +
              `Your PR has been merged, but no application services were changed.\n\n` +
              `This might be because:\n` +
              `- Only documentation was updated\n` +
              `- Only workflow files were changed\n` +
              `- Changes were outside of \`apps/\` directory\n\n` +
              `No production deployment is needed. Thank you for your contribution! ðŸ™`;

            github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Error handling job
  handle-errors:
    runs-on: self-hosted
    needs: [parse-command, detect-changes, preview-deploy, plan-preview, show-status, manual-cleanup]
    if: always() && contains(needs.*.result, 'failure')
    steps:
      - name: Handle workflow errors
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            
            let comment = `## âŒ Workflow Error\n\n`;
            comment += `Something went wrong while processing your command.\n\n`;
            comment += `**Possible issues:**\n`;
            comment += `- Kubernetes cluster connectivity problems\n`;
            comment += `- Invalid service directory structure\n`;
            comment += `- Manifest validation failures\n`;
            comment += `- Domain generator service unavailable\n\n`;
            comment += `**What you can do:**\n`;
            comment += `- Check the workflow logs for detailed error messages\n`;
            comment += `- Verify your service manifests are valid\n`;
            comment += `- Try running \`/help\` to see available commands\n`;
            comment += `- Contact the platform team if the issue persists\n\n`;
            comment += `*Error triggered by: @${context.actor}*`;

            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

            // React with confused emoji to the original comment
            if (context.payload.comment) {
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'confused'
              });
            }
                  echo "- **Domain ID:** \`$DOMAIN_ID\`" >> /tmp/status-output.md
                fi
                
                # Get service info
                SERVICES=$(kubectl get services -n $namespace --no-headers 2>/dev/null || echo "")
                if [ -n "$SERVICES" ]; then
                  echo "- **Services:**" >> /tmp/status-output.md
                  echo "$SERVICES" | while read svc_line; do
                    SVC_NAME=$(echo "$svc_line" | awk '{print $1}')
                    SVC_PORT=$(echo "$svc_line" | awk '{print $5}' | cut -d':' -f1)
                    echo "  - \`$SVC_NAME:$SVC_PORT\`" >> /tmp/status-output.md
                  done
                fi
                
                # Get pod status
                POD_STATUS=$(kubectl get pods -n $namespace --no-headers 2>/dev/null || echo "")
                if [ -n "$POD_STATUS" ]; then
                  RUNNING_PODS=$(echo "$POD_STATUS" | grep -c "Running" || echo "0")
                  TOTAL_PODS=$(echo "$POD_STATUS" | wc -l)
                  echo "- **Pods:** $RUNNING_PODS/$TOTAL_PODS running" >> /tmp/status-output.md
                fi
                
                echo "" >> /tmp/status-output.md
              fi
            done
          else
            echo "### â„¹ï¸ No Preview Environments Found" >> /tmp/status-output.md
            echo "" >> /tmp/status-output.md
            echo "No preview environments are currently active for this PR." >> /tmp/status-output.md
            echo "" >> /tmp/status-output.md
            echo "**To create preview environments:**" >> /tmp/status-output.md
            echo "- Run \`/preview\` to deploy all changed services" >> /tmp/status-output.md
            echo "- Run \`/preview <service>\` to deploy a specific service" >> /tmp/status-output.md
          fi

      - name: Comment status
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const status = fs.readFileSync('/tmp/status-output.md', 'utf8');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: status
            });

  # Manual cleanup command
  manual-cleanup:
    runs-on: self-hosted
    needs: parse-command
    if: needs.parse-command.outputs.command == 'cleanup'
    steps:
      - name: Manual cleanup
        run: |
          PR_NUMBER="${{ github.event.issue.number }}"
          
          echo "Manual cleanup requested for PR #$PR_NUMBER"
          
          # Find and cleanup preview namespaces
          PREVIEW_NAMESPACES=$(kubectl get namespaces -l pr-number=$PR_NUMBER -o name 2>/dev/null || true)
          
          if [ -n "$PREVIEW_NAMESPACES" ]; then
            for ns in $PREVIEW_NAMESPACES; do
              NAMESPACE_NAME=$(echo $ns | cut -d'/' -f2)
              
              # Delete domain
              DOMAIN_ID=$(kubectl get namespace $NAMESPACE_NAME -o jsonpath='{.metadata.labels.domain-id}' 2>/dev/null || echo "")
              if [ -n "$DOMAIN_ID" ]; then
